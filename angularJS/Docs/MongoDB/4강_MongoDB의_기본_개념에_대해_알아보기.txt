MongoDB 특징
  * MongoDB 소개
    - 10gen 사에서 개발한 솔루션(C++)
    - Key-value와 다르게 여러 용도로 사용이 가능(범용적)
    - 스키마를 고정하지 않은 형태
      a. 스키마 변경으로 오는 문제 없음
      b. 데이터를 구조화해서 json 형태로 저장(데이터를 key-value화 저장)
    - Join이 불가능하기 때문에 join이 필요없도록 데이터 설계 필요
  
  * MogoDB 특징
    - 메모리맵 형태의 파일엔진 DB이기 때문에 메모리에 의존적
    - 쌓아놓고 삭제가 없는 경우가 적합(로그데이터, 이벤트 참여 내역, 세션)
    - 트랜잭션이 필요한 금융, 결제, 빌링, 회원정보 등에는 부적합
    
    # 도큐먼트 데이터 모델 (데이터 설계를 "종이문서" 설계하듯이 설계해야 한다)
      - 속성의 이름과 값으로 이루어진 쌍의 집합
      - 속성은 문자열이나 숫자, 날짜 가능
      - 배열 또는 다른 도큐먼트를 지정하는 것도 가능
      - 하나의 document에 필요한 정보를 모두 담아야 함
      - one query로 모두 해결이 되게끔 collection model 설계를 해야 함
      
    # 도큐먼트 형태의 구조
      {
      	"_id" : objectId("4c03e856e528c2701930c091"),
      	"title" : "Welcome to MongoDB",
      	"body" : "Today, we're gonna totally rock your world...",
      	"published" : true,
      	"created" : "Mon May 31 2016 12:48:22 GMT-0400(EDT)",
      	1"tags" : ["databases", "MongoDB", "awesome" ],
      	"comments" : [
      						"comment_id" : "9023091210"
      						"author" : "Bob",
      						"email" : "bob@example.com",
      						"body" : "My mine has been totally blown!",
      						"created" : "Mon May 31 2016 12:48:22 GMT-0400(EDT)",
      					  ]
      }
      
      # JSON (JavaScript Object Notation)
        - lightweigt data 교환 형식
        - JavaScript의 Array 문법으로 데이터 구조를 기술하는 방법으로 XML이 가지는 유연성과 구조적 데이터 
          표현기능을 확보하면서, XML이 가진 오버헤드를 줄이는 방법으로 사용됨
        - 클라이언트에서 처리 퍼포먼스 높음
        - XML이 표현하는 구조적인 정보 모두 표현가능하며, 송수신 데이터로 XML을 사용하는 것에 비해 훨씬 빠르고, 간편

  * MongoDB 장점
    - Schema-less 구조 : 다양한 형태의 데이터 저장 가능, 데이터 모델의 유연한 변화 가능(데이터 모델 변경, 필드 확장 용이)
    - Read/Write 성능 뛰어남
    - Scale Out 구조 : 많은 데이터 저장 가능, 장비 확장이 간단함
    - JSON 구조 : 데이터 직관적 이해 가능
    - 사용 방법 쉽고, 개발이 편함
    
    # 빅데이터 처리 특화
      - Memory Mapped(데이터 쓰기 시에 OS의 가상 메모리에 데이터를 넣은 후 비동기로 디스크에 기록하는 방식)를 사용
      - 방대한 데이터를 빠르게 처리 가능
      - OS의 메모리를 활용하기 때문에 메모리가 차면 하드디스크로 데이터를 처리하여 속도가 급격히 느려짐
      - 하드웨어적인 측면에 투자가 필요
      
  * MongoDB 단점
    - 데이터 업데이트 중 장애 발생 시, 데이터 손실 가능
    - 많은 인덱스 사용 시, 충분한 메모리 확보 필요
    - 데이터 공간 소모가 RDBMS에 비해 많음(비효율적인 Key 중복 입력)
    - 복잡한 JOIN 사용시 성능 제약이 따름
    - transaction 지원이 RDBMS 대비 미약함
    - 제공되는 MapReduce 작업이 Hadoop에 비해 성능이 떨어짐
    
    # MongoDB 불안정성
      a. 데이터의 양이 많은경우
        - 일부 데이터가 손실 가능성 존재
        - 샤딩의 비정상적인 동작 가능성
        - 레플리카 프로세스의 비정상 동작 가능성
        
  * MongoDB Query
    # C (Create)
      - db.person.save({'name':'john'});
    # R (Read)
      - db.person.find();
    # U (Update)
      - db.users.update({name:'Johnny'}, {name:"Cash', languages:['english']});
    # D (Delete)
      - db.users.reove({name:'Sue'});
      
  * MongoDB Index
    - 다수 인덱스 설정 가능, 복합 인덱스 지원, 빠른 검색 지원
    - 도큐먼트에 저장된 데이터와 중복 저장 문제
    - 메모리가 부족한 시스템에서는 검색 속도 저하 문제
     
  * MongoDB 복제
    - Master-Slave 구조 구성
    - 데이터 복사본을 Slave에 배치
    - Master 장애에 따른 데이터 손실 없이 Slave 데이터 사용가능
    - Master 장애가 발생했을 때, Slave에서 Master를 선출가능( 중단없는 서비스 가능)
    - 데이터 손실을 최소화하기 위해 저널링 지원(MongoDB의 데이터 변화에 따른 모든 연산에 대한 로그 적재)
    
  * MongoDB 샤딩(데이터 분산 저장)
    # 대용량의 데이터를 저장하기 위한 방법
      - 소프트웨어 적으로 데이터베이스를 분산시켜 처리하는 구조
    # 샤딩 방식
      - 데이터베이스가 저장하고 있는 테이블을 테이블 단위로 분리하는 방법
      - 데이터베이스가 저장하고 있는 테이블 자체를 분할하는 방법
    # 분산 데이터베이스의 전통적인 분할 3계층 구조 지원
       - 응용 계층, 중개자 계층, 데이터 계층
       - 응용 계층은 데이터에 접근하기 위해 중개자를 통해 모든 데이터의 입출력을 처리
       - 추상화된 한개의 데이터베이스가 존재하는 것처럼 운용
       
  * MongoDB 맵리듀스(데이터 분산 연산)
    # 대용량의 데이터를 안전하고 빠르게 처리하기 위한 방법
      - 데이터를 분산하여 연산하고 다시 합치는 기술
      - 맵과 리듀스 단계로 나누어 처리하며, 사용자가 임의 코딩 가능
      - 입/출력 데이터는 Key-Value 형태로 구성
    # 한대 이상의 하드웨어를 활용하는 분산 프로그래밍 모델
      - 분산을 통해 분할된 조각으로 처리한 다음, 다시 모아서 훨씬 짧은 시간에 계산을 완료
    # 대용량 파일에 대한 로그 분석, 색인 구축 검색 등에 활용
    # 일괄 처리 방식으로 전체 데이터 셋을 분석할 필요가 있는 문제에 적합
    
      